import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, MagicMock, ANY
import uuid

# Adjust the import path based on your project structure
# Assuming 'server' is a package or added to PYTHONPATH
from server.main import app
from server.models import Course, CourseLevel, CourseStatus, Lesson, LessonStatus

client = TestClient(app)

# --- Test Data --- 
def create_test_course_payload(title="Test Course API Input", subject="Test Subject API Input", difficulty="easy"):
    """Payload for creating a course via the API (title, subject, and difficulty)."""
    return {
        "title": title,
        "subject": subject,
        "difficulty": difficulty
    }

def create_mock_course_dict(id_str=None, title="Mock Full Course Title", subject="Mock Full Course Subject", description="Mock Description"):
    """Creates a dictionary representing a full course object, as if returned by CRUD/DB."""
    course_id = id_str or str(uuid.uuid4())
    return {
        "id": course_id,
        "title": title,
        "subject": subject,
        "description": description,
        "lessons": [
            {
                "title": "Lesson 1 from Mock",
                "content_md": "Content for lesson 1 from mock",
                "external_links": ["http://example.com/mocklink"],
                "status": LessonStatus.PENDING.value
            }
        ],
        "raw_generated_content_md": "# Mock Raw MD Content"
    }

# --- Test Cases --- 

@patch('server.routers.courses.crud.create_course_with_team')
def test_create_course_success(mock_crud_create_course_with_team):
    """Test successful course creation with title and subject, AI generates the rest."""
    test_api_payload = create_test_course_payload(title="New AI Course", subject="AI Course Subject")
    
    mock_response_id = str(uuid.uuid4())
    mock_db_response = create_mock_course_dict(
        id_str=mock_response_id, 
        title="AI Generated Course Title",
        subject="AI Course Subject",
        description="This course was generated by an AI."
    )
    mock_crud_create_course_with_team.return_value = mock_db_response

    response = client.post("/courses/", json=test_api_payload)

    assert response.status_code == 200 # Changed from 201
    assert not response.content # Check for empty response body
    
    # Check how crud.create_course_with_team was called by the router
    mock_crud_create_course_with_team.assert_called_once_with(
        db=ANY, # Assuming db is passed as a dependency
        initial_title=test_api_payload["title"],
        subject=test_api_payload["subject"],
        difficulty=test_api_payload["difficulty"] # Ensure difficulty is asserted here
    )

@patch('server.routers.courses.crud.create_course_with_team')
def test_create_course_failure(mock_crud_create_course_with_team):
    """Test course creation failure (e.g., DB error)."""
    test_payload = create_test_course_payload()
    mock_crud_create_course_with_team.return_value = None # Simulate failure in CRUD operation

    response = client.post("/courses/", json=test_payload)

    assert response.status_code == 400
    assert response.json() == {"detail": "Failed to create course with agent team. Check server logs and agent_sessions table for details."}
    mock_crud_create_course_with_team.assert_called_once()

@patch('server.routers.courses.crud.get_all_courses')
def test_read_all_courses_success(mock_get_all):
    """Test retrieving all courses successfully."""
    mock_courses = [
        create_mock_course_dict(title="Course 1"),
        create_mock_course_dict(title="Course 2")
    ]
    mock_get_all.return_value = mock_courses

    response = client.get("/courses/?skip=0&limit=10")

    assert response.status_code == 200
    response_data = response.json()
    assert len(response_data) == 2
    assert response_data[0]["title"] == "Course 1"
    assert response_data[1]["title"] == "Course 2"
    mock_get_all.assert_called_once_with(db=ANY, skip=0, limit=10)

@patch('server.routers.courses.crud.get_all_courses')
def test_read_all_courses_empty(mock_get_all):
    """Test retrieving all courses when none exist."""
    mock_get_all.return_value = []

    response = client.get("/courses/")

    assert response.status_code == 200
    assert response.json() == []
    mock_get_all.assert_called_once()

@patch('server.routers.courses.crud.get_course')
def test_read_single_course_success(mock_get):
    """Test retrieving a single course successfully."""
    test_id = str(uuid.uuid4())
    mock_db_course = create_mock_course_dict(id_str=test_id)
    mock_get.return_value = mock_db_course

    response = client.get(f"/courses/{test_id}")

    assert response.status_code == 200
    response_data = response.json()
    assert response_data["id"] == test_id
    assert response_data["title"] == "Mock Full Course Title"
    mock_get.assert_called_once_with(db=ANY, course_id=test_id)

@patch('server.routers.courses.crud.get_course')
def test_read_single_course_not_found(mock_get):
    """Test retrieving a single course that does not exist."""
    test_id = str(uuid.uuid4())
    mock_get.return_value = None # Simulate course not found

    response = client.get(f"/courses/{test_id}")

    assert response.status_code == 404
    assert response.json() == {"detail": "Course not found"}
    mock_get.assert_called_once_with(db=ANY, course_id=test_id)

@patch('server.routers.courses.crud.update_course')
@patch('server.routers.courses.crud.get_course') # Needed for update check
def test_update_course_success(mock_get, mock_update):
    """Test successfully updating a course."""
    test_id = str(uuid.uuid4())
    update_payload = {"title": "Updated Title", "status": "published"}

    # Mock the response from the update operation
    updated_mock_data = create_mock_course_dict(id_str=test_id, title="Updated Title")
    updated_mock_data["status"] = CourseStatus.PUBLISHED.value # Reflect update
    mock_update.return_value = updated_mock_data

    response = client.patch(f"/courses/{test_id}", json=update_payload)

    assert response.status_code == 200
    response_data = response.json()
    assert response_data["id"] == test_id
    assert response_data["title"] == "Updated Title"
    mock_update.assert_called_once()

    # Check that the correct update data was passed using kwargs
    call_kwargs = mock_update.call_args.kwargs
    assert 'course_id' in call_kwargs
    assert call_kwargs['course_id'] == test_id
    assert call_kwargs['course_update'].title == update_payload["title"]
    assert call_kwargs['course_update'].status.value == update_payload["status"] # Compare enum value
    assert call_kwargs['course_update'].level is None # Ensure only provided fields are sent
    assert 'db' in call_kwargs

@patch('server.routers.courses.crud.update_course')
@patch('server.routers.courses.crud.get_course')
def test_update_course_not_found(mock_get, mock_update):
    """Test updating a course that does not exist."""
    test_id = str(uuid.uuid4())
    update_payload = {"title": "Updated Title"}
    
    # Simulate update failure because get_course called inside update returns None
    mock_update.return_value = None 
    # Simulate get_course called in the endpoint check returning None
    mock_get.return_value = None 

    response = client.patch(f"/courses/{test_id}", json=update_payload)

    assert response.status_code == 404
    assert response.json() == {"detail": f"Course with id {test_id} not found"}
    # Update might be called, but get inside the endpoint prevents proceeding
    # mock_update.assert_called_once() # Might or might not be called depending on Supabase client
    mock_get.assert_called_once_with(db=ANY, course_id=test_id)

@patch('server.routers.courses.crud.update_course')
@patch('server.routers.courses.crud.get_course')
def test_update_course_internal_error(mock_get, mock_update):
    """Test an internal server error during course update."""
    test_id = str(uuid.uuid4())
    update_payload = {"title": "Updated Title"}
    
    # Simulate update failure (returns None)
    mock_update.return_value = None 
    # Simulate get_course called in endpoint check returning the *existing* course
    mock_get.return_value = create_mock_course_dict(id_str=test_id) 

    response = client.patch(f"/courses/{test_id}", json=update_payload)

    assert response.status_code == 500
    assert response.json() == {"detail": f"Failed to update course {test_id}"}
    mock_update.assert_called_once()
    mock_get.assert_called_once_with(db=ANY, course_id=test_id)

# Helper for assertions: patch 'ANY' where necessary
from unittest.mock import ANY 